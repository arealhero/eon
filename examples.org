* Empty main
#+begin_src c
  main: () = {}
#+end_src

* Empty main with explicit return
#+begin_src c
  main: () -> s32 = { return 0; }
#+end_src

* Main with function call
#+begin_src c
  foo: () -> s32 = {
      result := 2;
      return result + result;
  }

  main: () -> s32 = {
      return foo();
  }
#+end_src

* Main with arguments
#+begin_src c
  main: (args_count: C_Int, args: [] C_String) = {
      for i := 0; i < args_count; ++i {
          println("arg[{}] = {}", i+1, args[i]);
      }
  }
#+end_src

* WIP: Range-based for loop
#+begin_src c
  print_strings: (strings: [] String) -> nothing = {
      for string, index in strings {
          println("{}. {}", index + 1, string);
      }
  }
#+end_src

* ~to_upper_inplace~ ASCII function
#+begin_src c
  to_upper_inplace: (string: mutable String) = {
      for i := 0; i < string.length; ++i {
          if 'a' <= string.data[i] && string.data[i] <= 'z' {
              string.data[i] = 'A' + (string.data[i] - 'a');
          }
      }
  }

  main: (args_count: C_Int, args: [] C_String) = {
      // NOTE: This should fail to compile because we cannot modify string literals.
      // println("to_upper({}) = {}", "hello world!", to_upper("hello world!"));

      string: mutable String = "hello world!";
      // NOTE: This would work fine if we guarantee that arguments will be computed from left to right?
      //       Or maybe not because we are modifying 'string' in 'to_upper'.
      // println("to_upper({}) = {}", string, to_upper(string));

      print("to_upper({}) = ", string);
      to_upper_inplace(string);
      print("{}\n", string);
  }
#+end_src

* Factorial
** Without memoization, recursive
#+begin_src c
  factorial: (n: s32) -> s32 = {
      if n == 1 {
          return 1;
      }

      return n * factorial(n - 1);
  }

  main: () -> s32 = {
      return factorial(5);
  }
#+end_src

** With memoization, recursive
#+begin_src c
  MAX_ARGUMENT: s32 = 10; // Or MAX_ARGUMENT := 10;

  factorial: (n: s32) -> s32 = {
      memoization: persistent [MAX_ARGUMENT] s32; // NOTE: default initialized to zero.

      if n == 0 {
          return 1;
      }

      if memoization[n - 1] == 0 {
          memoization[n - 1] = n * factorial(n - 1);
      }

      return memoization[n - 1];
  }

  main: () -> s32 = {
      return factorial(5) + factorial(3);
  }
#+end_src

