// BNF

// NOTE(vlad): Lexer.

letter: "[a-zA-Z]";
digit: "[0-9]";

// TODO(vlad): Support floating-point numbers.
number: optional_number_sign digit number_tail;
optional_number_sign: EPS | "-" | "+";
number_tail: EPS | digit number_tail;

string_literal: "\"" ANY "\"";

identifier: identifier_start identifier_end;

identifier_start: letter | "_";
identifier_end: EPS | identifier_body identifier_end;
identifier_body: letter | digit | "_";

// NOTE(vlad): Parser.

program: function_definitions;

function_definitions: EOF | function_definition function_definitions;
function_definition: identifier ":" function_type "=" "{" function_body "}";
function_body: statements;

statements: EPS | statement statements;
statement: variable_definition;

variable_definition: identifier ":" optional_variable_type optional_variable_assignment ";";

function_type: "(" arguments_declaration ")" "->" type;
type: function_type | identifier; // TODO(vlad): Add support for arrays, pointers, qualifiers, etc. @tag(eon-grammar)

arguments_declaration: EPS | argument_declaration arguments_declaration_tail;
argument_declaration: identifier ":" type; // TODO(vlad): Add default values support. @tag(eon-grammar)
arguments_declaration_tail: EPS | "," argument_declaration arguments_declaration_tail;

optional_variable_type: EPS | type;
// TODO(vlad): Rename to 'optional_variable_initialisation' or something.
optional_variable_assignment: EPS | "=" expression; // TODO(vlad): Support 'uninitialized' keyword or something.

expression: number | string_literal;
