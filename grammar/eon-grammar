// BNF

START: program;

// NOTE(vlad): Lexer.

letter: "[a-zA-Z]";
digit: "[0-9]";

// TODO(vlad): Support floating-point numbers.
number: optional_number_sign digit number_tail;
optional_number_sign: EPS | "-" | "+";
number_tail: EPS | digit number_tail;

string_literal: "\"" ANY "\"";

identifier: identifier_start identifier_end;

identifier_start: letter | "_";
identifier_end: EPS | identifier_body identifier_end;
identifier_body: letter | digit | "_";

// NOTE(vlad): Parser.

code_block: "{" statements "}";

program: function_definitions;

function_definitions: EOF | function_definition function_definitions;
function_definition: identifier ":" function_type "=" code_block;

statements: EPS | statement statements;
statement: variable_definition | return_statement;

variable_definition: identifier ":" optional_variable_type optional_variable_assignment ";";

return_statement: "return" optional_expression ";";

if_statement: "if" expression code_block optional_else_statement;
optional_else_statement: EPS | "else" if_statement_or_code_block;
if_statement_or_code_block: if_statement | code_block;

function_type: "(" arguments_declaration ")" "->" type;
type: function_type | pointer_type | identifier; // TODO(vlad): Add support for arrays, qualifiers, etc. @tag(eon-grammar)
pointer_type: "*" type;

arguments_declaration: EPS | argument_declaration arguments_declaration_tail;
argument_declaration: identifier ":" type; // TODO(vlad): Add default values support. @tag(eon-grammar)
arguments_declaration_tail: EPS | "," argument_declaration arguments_declaration_tail;

optional_variable_type: EPS | type;
// TODO(vlad): Rename to 'optional_variable_initialisation' or something.
optional_variable_assignment: EPS | "=" expression; // TODO(vlad): Support 'uninitialized' keyword or something.

expression: comparison_expression;

comparison_expression: additive_expression optional_comparison_expression_tail;
optional_comparison_expression_tail: EPS
                                   | "==" comparison_expression
                                   | "!=" comparison_expression;

additive_expression: multiplicative_expression optional_additive_expression_tail;
optional_additive_expression_tail: EPS
                                 | "+" additive_expression
                                 | "-" additive_expression;

multiplicative_expression: call_expression optional_multiplicative_expression_tail;
optional_multiplicative_expression_tail: EPS
                                       | "*" multiplicative_expression
                                       | "/" multiplicative_expression;

call_expression: primary_expression optional_call_expression_tail;
optional_call_expression_tail: EPS
                             | "(" optional_arguments ")";

// FIXME(vlad): Forbid assignment expressions here?
optional_arguments: EPS | optional_argument optional_arguments_tail;
optional_argument: expression; // TODO(vlad): Support named arguments like 'foo(a = 10, b = 20)' or something.
optional_arguments_tail: EPS | "," optional_argument optional_arguments_tail;

primary_expression: number | string_literal | identifier | "(" expression ")";

optional_expression: EPS | expression;
